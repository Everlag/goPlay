package main

import(
	"fmt"
	"os/exec"
	"strconv"

	"math/rand"
	"./HitBoxComm"
	"encoding/json"

	"strings"
	"time"
)

//we'll be using xdotool to send keyboard commands!
func xPress(aKey string) {
	app:= "xdotool"

	cmd:= exec.Command(app, "key", aKey)

	fmt.Println(cmd.Args)

	err:= cmd.Run()
	//if we can't press a key it isn't that big of an issue
	if err!=nil{
		fmt.Println("Error: ", err.Error()) 
	}
}

//assumes that the game is already focused... it really should be
func killGame() {
	xPress("Escape")
	xPress("Escape")
	xPress("Escape")
	xPress("Escape")
	xPress("Escape")
	xPress("Escape")
	xPress("Escape")
	xPress("Escape")
	xPress("Escape")
	xPress("Escape")
	xPress("Escape")
}

//to be more accurate, we can schedule keys using type and a --delay
	//a window will directly pipe the keys to that window
func xType(keys, aWindow string) {
	
	app:= "xdotool"

	cmd:= exec.Command(app, "search", aWindow, "windowactivate", "type", "--delay", strconv.Itoa(actionDelayInt), keys )

	fmt.Println(cmd.Args)

	err:= cmd.Run()
	//if we can't press a key it isn't that big of an issue
	if err!=nil{
		fmt.Println("Error: ", err.Error()) 
	}

}

//use x to switch to the window we want to pipe input to
func xActive(aWindow string) {
	app:= "xdotool"

	arg1:= "search"

	cmd:= exec.Command(app, arg1, aWindow, "windowactivate", "--sync")

	fmt.Println(cmd.Args)

	err:= cmd.Run()
	//if we can't press a key it isn't that big of an issue
	if err!=nil{
		fmt.Println("Error: ", err.Error()) 
	}
}

var(
	generatorSeed = 1398424523

	batchSize = 400 //how many keystrokes to batch between generating new ones
	userBatch = 0 //keystrokes to buffer from hitbox before performing
	targetWindow = "pokemon"
	actionDelayInt = 100

	randInput = true
)
var keyMap = map[int]string{}

//the mapping from integers generated by the noise function
//to commands to the target application
//REBINDABLE KEYS ARE A GODSEND
var cleanMap = map[int]string{
	0: "", //to be used to force a button
	1: aBut, //is A button
	2: bBut, //is B button
	3: startBut, //is start
	4: selectBut, //selectBut, //is select, or would be if it wasn't a bad idea
	5: upBut, //is up
	6: downBut, //is down
	7: leftBut, //is left
	8: rightBut, //if right
}

var inputMap = map[string]string{
	//next few are logical button maps
	"b": bBut,
	"select": selectBut,
	"start": startBut,
	"a": aBut,
	"up": upBut,
	"down": downBut,
	"left": leftBut,
	"right": rightBut,
}

const(
	aBut = "k"
	bBut = "l"
	startBut = "m"
	selectBut = "n"
	upBut = "w"
	downBut = "s"
	rightBut = "d"
	leftBut = "a"
)

//sets the eumator to running fast
//or slow
func toggleFast() {
	xType(" ` ", targetWindow)
}

//gets input from rng
func getInputRand() string {
	var batch string
	for i := 0; i < batchSize; i++{
		key:= rand.Intn(9)

		batch += keyMap[key]

	}

	return batch
}

type hitBoxMsg struct{
	Method string
	Params hitBoxMsgParams
}

type hitBoxMsgParams struct{
	Channel, Name, Text string
}

//attempts to parse a message out of the text
//that appears at the front of it and is found within inputMap
//
//returns the command provided by inputMap
func getCommand(someText string) string {
	var command string
	var textToPass string

	//first, check to see if there are spaces
	if strings.Index(someText, " ")== -1 {
		//we know this is a single command
		textToPass = someText

	}else{
		//it has a space, so parse out everything after
		textToPass = strings.Split(someText, " ")[0]
	}

	//try to pass it to the inputMap
	var ok bool
	command, ok= inputMap[textToPass]

	//ahahah, its a joke...
	if !ok{
		command = ""
	}

	return command
}

var gameList []string = []string{"FinalFantasy1+2", "FinalFantasy4", "FinalFantasy5", "AdvanceWars", "PokemonEmerald"}
//maps a game in game list to the window name
var gameMap = map[string]string{
	"FinalFantasy1+2":"fft",
	"PokemonEmerald": "emerald",
}

func main() {
	//set the window focus up
	targetWindow = gameMap[ gameList[0] ]
	xActive(targetWindow)
	time.Sleep(2 * time.Microsecond)

	keyMap = cleanMap

	//get the connection to the chat
	channel:= "aChannel of some description goes here!"

	//a lock to make sure we don't access the reader
	//before it is intialized
	readyChan:= make(chan bool)

	//where we expect our data to be stored
	commChan:= make(chan []byte)

	connection:= HitBoxComm.GetConnection(channel, readyChan, commChan)

	//block until we receive the signal
	<- readyChan

	fmt.Println(connection.Received)
	fmt.Println("ahahah")

	var data []byte
	var msg hitBoxMsg
	var command string
	var batch string
	//now enter the main loop, we'll react to messages here!
	for{

		//continually read and block from the message channel
		data= <- connection.Received

		//attempt to unmarhsal the received data:
		err:= json.Unmarshal(data, &msg)
		if err!=nil {
			//give up on this message
			fmt.Println("Received un-unmarshal-able message!")
			//it'll get overwritten
			continue
		}

		//at this point, the message is usable as a struct
			//make sure it is a chatMsg
		if msg.Method!="chatMsg" {
			//throw away the data
			continue
		}

		//at this point, we know this is a chat message, pass it to
		//our parser. the command will be the first word
		fmt.Println(msg.Params.Text)
		command = getCommand(msg.Params.Text)
		fmt.Println(command)

		batch+= command
		if len(batch)>userBatch{
			xType(batch, targetWindow)
			batch = ""
		}

	}


	//gotta go FAST
	/*
	toggleFast()

	for{
		//enter into the main loop
		batch:= getInputRand()
		fmt.Println(batch)
		xType(batch, targetWindow)

		time.Sleep( 300 * time.Millisecond )
	}
	*/

}